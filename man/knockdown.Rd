% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knockdown.R
\name{knockdown}
\alias{knockdown}
\title{Compute mooring knockdown by a horizontal current}
\usage{
knockdown(m, u = 1, niteration = 30, convergenceCriterion = 1e-04, debug = 0L)
}
\arguments{
\item{m}{an object of the \code{"mooring"} class, usually created with
\code{\link[=discretise]{discretise()}}.}

\item{u}{either a non-negative number indicating depth-independent velocity,
or a function that returns that velocity as a function of depth (m)
below the ocean surface.}

\item{niteration}{integer value setting maximum number of
iterations that will be taken in order to achieve convergence (see
also \code{convergenceCriterion}).}

\item{convergenceCriterion}{numeric value giving a convergence
criterion to stop iterating the solution.  If the RMS difference in
z values between iterations falls below the product of
\code{convergenceCriterion} and the water depth, then the iteration loop
is stopped early. Otherwise, once \code{niteration} iterations are
permitted, a warning is issued.  (Setting \code{debug} to a positive
value will cause information about each iteration to be printd.)}

\item{debug}{an integer value (or a numeric that can be converted to an
integer) that controls debugging. If this is positive, then some debugging
information may be printed by the function.}
}
\value{
a new \code{mooring} object representing the deformed mooring,
with \code{x} and \code{z} values updated (and original values saved as \code{x0}
and \code{z0}). In addition, the stress and angle of each element is
stored in fields named \code{tau} and \code{phi}, the latter in radians.
Attributes are added to the object to describe the solution in more
detail.  The \code{u} attribute stores the value supplied to
\code{knockdown()}, and \verb{waterDepth' stores the water depth that was supplied to the [anchor()] call.  An overview of the iterative solution is provided in the }iterationCount\code{and}iterationChange\verb{attributes, which store the number of iterations used in the computation, and the RMS change in}z` over the final iteration.
}
\description{
The current may be a depth-independent or depth-dependent, as
specified by the \code{u} argument.  The computation is iterated at most
\code{niteration} times until the RMS deviation between computed z
values falls below the product of \code{convergenceCriterion} and wire
length. The returned result has an attribute named \code{u} that holds
the value of that argument, and this is how a later call to
\code{\link[=plot.mooring]{plot.mooring()}} is able to display a velocity profile; see
\dQuote{Examples} 2 and 3.
}
\examples{
# Illustrate importance of drag on the wire.
library(mooring)
m <- mooring(anchor(depth = 100), wire(length = 80), float("16in Viny"))
md <- discretise(m)

# Example 1: no current
plot(md)

# Example 2: uniform 1 m/s (approx. 2 knot) current
par(mfrow = c(1, 2))
k1 <- knockdown(md, u = 1)
plot(k1, which = "velocity")
plot(k1)

# Example 3: 1 m/s current at surface, decaying exponentially below
k2 <- knockdown(md, u = function(depth) 1.0 * exp(-depth / 30))
par(mfrow = c(1, 2))
plot(k2)
plot(k2, which = "velocity")

# Example 4: as Example 3, but show knockdown and tension
# The red dashed line in the tension plot indicates the
# anchor weight.
k2 <- knockdown(md, u = function(depth) 1.0 * exp(-depth / 30))
par(mfrow = c(1, 2))
plot(k2, which = "knockdown")
plot(k2, which = "tension")

}
\author{
Dan Kelley
}
