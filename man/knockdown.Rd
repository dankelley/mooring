% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knockdown.R
\name{knockdown}
\alias{knockdown}
\title{Compute mooring knockdown by a horizontal current}
\usage{
knockdown(m, u = 1, niteration = 30, convergenceCriterion = 1/500, debug = 0L)
}
\arguments{
\item{m}{an object of the \code{"mooring"} class, usually created with
\code{\link[=segmentize]{segmentize()}}.}

\item{u}{either a non-negative number indicating depth-independent velocity,
or a function that returns that velocity as a function of depth (m)
below the ocean surface.}

\item{niteration}{integer value setting maximum number of
iterations that will be taken in order to achieve convergence (see
also \code{convergenceCriterion}).}

\item{convergenceCriterion}{numeric value giving a convergence
criterion to stop iterating the solution.  If the RMS difference in
z values between iterations falls below the product of
\code{convergenceCriterion} and the water depth, then the iteration loop
is stopped early. Otherwise, once \code{niteration} iterations are
permitted, a warning is issued.  (Setting \code{debug} to a positive
value will cause information about each iteration to be printd.)}

\item{debug}{an integer value (or a numeric that can be converted to an
integer) that controls debugging. If this is positive, then some debugging
information may be printed by the function.}
}
\value{
\code{knockdown} returns a \code{mooring} object representing the
deformed mooring, with \code{x} and \code{z} values updated, with the
original values being saved as \code{x0} and \code{z0}. In addition, the
stress and angle of each element is stored in fields named \code{tau}
and \code{phi}, the latter in radians. Attributes are added to the
object to describe the solution in more detail.  The \code{u} attribute
stores the value supplied to \code{knockdown()}, and \code{waterDepth} stores
the water depth that was supplied to the \code{\link[=anchor]{anchor()}} call.  An
overview of the iterative solution is provided in the
\code{iterationCount} and \code{iterationChange} attributes, which store the
number of iterations used in the computation, and the RMS change in
\code{z} over the final iteration.
}
\description{
The current may be a depth-independent or depth-dependent, as
specified by the \code{u} argument.  The computation is iterated at most
\code{niteration} times until the RMS deviation between computed z
values falls below the product of \code{convergenceCriterion} and wire
length. The returned result has an attribute named \code{u} that holds
the value of that argument, and this is how a later call to
\code{\link[=draw]{draw()}} is able to display a velocity profile; see
Examples 2 and 3.
}
\examples{
# Illustrate importance of drag on the wire.
library(mooring)
m <- mooring(anchor(), wire(length = 80), float("16in Viny"), waterDepth = 100)
md <- segmentize(m)

# Example 1: no current
draw(md)

# Example 2: uniform 1 m/s (approx. 2 knot) current
par(mfrow = c(1, 2))
k1 <- knockdown(md, u = 1)
draw(k1, which = "velocity")
draw(k1)

# Example 3: 1 m/s current at surface, decaying exponentially below
k2 <- knockdown(md, u = function(depth) 1.0 * exp(-depth / 30))
par(mfrow = c(1, 2))
draw(k2)
draw(k2, which = "velocity")

# Example 4: as Example 3, but show knockdown and tension
# The red dashed line in the tension plot indicates the
# anchor weight.
k2 <- knockdown(md, u = function(depth) 1.0 * exp(-depth / 30))
par(mfrow = c(1, 2))
draw(k2, which = "knockdown")
draw(k2, which = "tension")

}
\author{
Dan Kelley
}
